# Ethereum
Ethereum is an open-source, public, blockchain-based distributed computing platform and operating system featuring smart contract (scripting) functionality. Ether is a cryptocurrency whose blockchain is generated by the Ethereum platform. Ether can be transferred between accounts and used to compensate participant mining nodes for computations performed.Ethereum provides a decentralized Turing-complete virtual machine, the Ethereum Virtual Machine (EVM), which can execute scripts using an international network of public nodes. 

#Demo - We'll build a decentralized conference ticket purchasing web app
#What is Ethereum?
Ethereum is a platform to easily build decentralized applications (Đapps) using blockchain technology.

alt text

A decentralized what?
alt text

A Dapp

Doesn't depend on any specific party existing.
Not for selling a specific party's service
Instead, a tool for people and organizations on different sides of an interaction used to come together without any centralized intermediary.
Dapp Examples built using Ethereum
http://weifund.io/

Provides an open platform for crowdfunding campaigns that leverages smart contracts.
It enables contributions to be turned into contractually backed digital assets that can be used, traded or sold within the Ethereum ecosystem.
https://www.augur.net/

An open-source prediction & forecasting market platform that allows anyone to forecast events and get rewarded for predicting them correctly
Predictions on future real world events
If a person buys shares in a winning prediction, they receive monetary rewards.
https://www.provenance.org/

Using Ethereum to make opaque supply chains more transparent
By tracing the origins and histories of products, the project aims to build an open & accessible framework of information so consumers can make informed decisions when they buy products.
Let's get to the Architecture
The Stack
alt text

alt text

Overview
alt text

Let's talk Merkle Trees for a second
Merkle trees are a fundamental part of what makes blockchains tick.
Theoretically possible to make a blockchain without Merkle trees by creating giant block headers that directly contain every transaction
But Doing that poses large scalability challenges
Merkle trees make it possible to build Ethereum nodes that run on all sorts of computers
A way of hashing a large number of “chunks” of data together which relies on splitting the chunks into buckets, where each bucket contains only a few chunks, then taking the hash of each bucket and repeating the same process, continuing to do so until the total number of hashes remaining becomes only one: the root hash
alt text

Allows for Merkle Proofs
A Merkle proof consists of a chunk, the root hash of the tree, and the “branch” consisting of all of the hashes going up along the path from the chunk to the root
Someone reading the proof can verify that the hashing is consistent going all the way up the tree
Allows a mechanism for authenticating a small amount of data, like a hash, to be extended to also authenticate large databases of potentially unbounded size.
The Bitcoin blockchain uses Merkle proofs in order to store the transactions in every block:

alt text

The benefit that this provides is the concept that Satoshi described as “simplified payment verification”: instead of downloading every transaction and every block, a “light client” can only download the chain of block headers, 80-byte chunks of data for each block that contain only five things:

A hash of the previous header
A timestamp
A mining difficulty value
A proof of work nonce
A root hash for the Merkle tree containing the transactions for that block.
It's limitation is that whileit can prove the inclusion of transactions, they cannot prove anything about the current state (eg. digital asset holdings, name registrations, the status of financial contracts, etc).

So Every block header in Ethereum contains not just one Merkle tree, but three trees for three kinds of objects:

Transactions
Receipts (essentially, pieces of data showing the effect of each transaction)
State
alt text

This allows clients to easily make and get verifiable answers to queries like

Tell me all instances of an event of type X (eg. a crowdfunding contract reaching its goal) emitted by this address in the past 30 days
The software libraries on GitHub
Serverless stack

The Ethereum Virtual Machine is ‘calculate’ element that runs contract logic
Swarm is Peer-to-Peer file sharing, similar to BitTorrent, but incentivised with micropayments of ETH.
Whisper is an encrypted messaging protocol that allows nodes to send messages directly to each other in a secure way and that also hides the sender and receiver from third party snoopers.
To run Ethereum, you can download (or write yourself if you have the patience) some software called an Ethereum client. Just like BitTorrent or Bitcoin, the Ethereum client will connect over the internet to other people’s computers running similar client software and start downloading the Ethereum blockchain from them to catch up. It will also independently validate that each block conforms to the Ethereum rules.

You can use it to:

Connect to the Ethereum network
Explore Ethereum’s blockchain
Create new transactions and smart contracts
Run smart contracts
Mine for new blocks
Your computer becomes a ‘node’ on the network, running an Ethereum Virtual Machine, and behaves equivalently to all the other nodes. Remember in a peer-to-peer network there is no ‘master’ server and any computer has equivalent powers or status to any other.
alt text

Ethereum clients
geth (written in a language called Go) https://github.com/ethereum/go-ethereum
eth (written in C++) https://github.com/ethereum/cpp-ethereum
pyethapp (written in Python) https://github.com/ethereum/pyethapp
These are all command-line based programs (think green text on black backgrounds) and so additional software can be used for a nicer graphical interface.

Currently the official and most popular graphical one is Mist (https://github.com/ethereum/mist), which runs on top of geth or eth.

Smart Contract languages
alt text

There are three common languages smart contracts are written in, which can be compiled into smart contracts and run on Ethereum Virtual Machines.

Solidity – similar to the language Javascript. This is currently the most popular and functional smart contract scripting language.
Serpent – similar to the language Python, and was popular in the early history of Ethereum.
LLL (Lisp Like Language) – similar to Lisp and was only really used in the very early days. It is probably the hardest to write in.
Workflow for Deploying Smart Contracts
The workflow is:

Start an Ethereum node (e.g. geth or testrpc or ethersim)
Compile your Solidity smart contract using solc => get back the binary
Deploy your compiled contract to the network. (This step costs ether and signs the contract using your node’s default wallet address, or you can specify another address.) => get back the contract’s blockchain address and ABI (a JSON-ified representation of your compiled contract’s variables, events and methods that you can call)
Call stuff in the contract using web3.js’s JavaScript API to interact with it (This step may cost ether depending on the type of invocation.)
alt text

Model View Controller architecutre still applies in a Dapp.
your controller will speak to blockchains and DHTs instead of servers.
We need smart models, thin controllers, and dumb views.
certain elements that need consensus via smart contracts that would usually require a server (like usernames or financial actions)
Smart contracts are technically ‘models’ and you can feed data into them via transactions, but they are not the de facto ‘model’ in MVC architecture. They can work alongside your existing models but their utility on really applies in specific scenarios. These will come up on a case-by- case basis.
